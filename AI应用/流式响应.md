# 1）你这段代码在做什么（先把全局图景立起来）

你图里类似这样：

```java
@GetMapping(value="/chat/stream", produces="text/html;charset=UTF-8")
public Flux<String> chatStream(@RequestParam("msg") String message) {
    return chatClient.prompt().user(message).stream().content();
}
```

这表示：

- 浏览器请求 `/chat/stream?msg=xxx`
- 后端不等模型全部生成完才返回，而是**边生成边返回**
- 返回的是一个“数据流”，Spring WebFlux 会把它**持续写到 HTTP 响应体**里

------

# 2）关键术语

## 2.1 call vs stream

- **call（非流式）**：模型生成完一次性返回（适合短回答、接口调用简单）
- **stream（流式）**：模型一边生成 token/片段，你一边往外吐（体验好、首字延迟低）

## 2.2 同步/异步 + 阻塞/非阻塞

- **阻塞（Blocking）**：线程在等 I/O（等模型、等网络、等 DB）
- **非阻塞（Non-blocking）**：线程不傻等，I/O 就绪再回调继续（WebFlux 的核心）
- 流式返回通常搭配非阻塞框架（WebFlux/Netty），更“抗并发”。

## 2.3 SSE / Chunked（两种常见流式形态）

- **Chunked Transfer**：HTTP 分块传输，服务端不断写数据块，浏览器不断读
- **SSE（Server-Sent Events）**：一种更标准的“文本事件流”，`Content-Type: text/event-stream`，前端用 `EventSource`

你现在用 `text/html` 也能流（浏览器会把它当 HTML 文本），但更工程化推荐 SSE。

------

# 3）你问的核心：Flux<String> 是什么意思？

## 3.1 Flux 的定义

`Flux<T>` 是 **Reactor（响应式编程）**里的类型，表示：

> **0..N 个元素组成的异步序列**（可能慢慢来，也可能无限）

对比一下：

- `String`：一次性返回一个字符串（同步结果）
- `Mono<String>`：**异步**返回一个字符串（0..1）
- `Flux<String>`：**异步**返回很多段字符串（0..N），每段可能间隔几十毫秒到几百毫秒到来

你现在 `Flux<String>` 的每个 `String` 通常就是模型流式输出的一个片段（token 或 chunk）。

## 3.2 为啥流式要用 Flux

因为流式的本质是：

- 第 1 段来了就先返回第 1 段
- 第 2 段来了再继续写第 2 段
- …直到完成

Flux 正好表达这种“不断产生元素”的过程。

## 3.3 Spring 怎么把 Flux 变成浏览器看到的“流”

Spring WebFlux 看到返回 `Flux<String>`，会：

- 设置响应为 streaming（底层分块传输）
- **订阅**这个 Flux（subscribe）
- 每来一个元素就写到 response body 并 flush
- Flux 完成就结束响应

> 一句话：`Flux<String>` 在后端是“数据流”，在浏览器看来是“响应体不断追加内容”。

------

# 4）@GetMapping 里的 value / produces / charset 到底是什么

你问得非常关键：这些到底是针对 **输入** 还是 **输出**？

## 4.1 `value="/chat/stream"` 是给谁看的？

这是 **路由**：

- 给浏览器/前端用来访问接口的 URL 路径
- 比如浏览器访问：`GET /chat/stream?msg=你好`

它跟编码无关，就是“这个方法处理哪个路径”。

------

## 4.2 @RequestParam("msg") 是输入从哪来

- `msg` 来自 URL 查询参数：`?msg=xxx`
- 编码层面：浏览器会按 URL 编码规则发送（例如 UTF-8 百分号编码），Spring 会解码成 Java `String`

> 所以：`@RequestParam` 是输入绑定，跟 `produces` 是两回事。

------

## 4.3 produces 是什么？（重点）

`produces` 指的是：

> **这个接口返回的响应 Content-Type 是什么**（输出格式）

比如：

- `produces="application/json"`：返回 JSON
- `produces="text/plain"`：返回纯文本
- `produces="text/event-stream"`：返回 SSE 流
- `produces="text/html"`：返回 HTML（或当作 HTML 文本流）

所以 `produces` 明确管的是 **输出**，不是输入。

------

## 4.4 charset=UTF-8 是什么作用

`charset` 是 `Content-Type` 的参数，告诉客户端：

> 这段文本响应体用什么字符集编码

例如响应头可能是：

```
Content-Type: text/html; charset=UTF-8
```

如果没有 charset，会发生什么？

- 很多现代浏览器会“猜”或默认 UTF-8，但不保证
- 在一些环境下可能出现中文乱码（尤其是 text/html / text/plain 的流式片段）

所以 `charset=UTF-8` 的作用就是：**防止中文等非 ASCII 字符在浏览器显示乱码**。

> 结论：`charset` 也是**输出编码**（响应体的编码），不是输入参数的编码。

------

# 5）编码字符集到底是什么？

- **字符集（Charset）**：字符和数字之间的映射规则（比如 Unicode 定义了“你”这个字的码点）
- **字符编码（Encoding）**：把字符映射成字节的具体规则（UTF-8/UTF-16…）

HTTP 传输的是字节，浏览器要把字节还原成文字，必须知道用什么编码。
`charset=UTF-8` 就是在告诉浏览器：**按 UTF-8 解码这些字节**。

------

# 6）为什么很多示例用 text/html;charset=UTF-8？更推荐什么？

你截图里用 `text/html`，它能工作，但更“标准”的流式有两种：

## 6.1 推荐：SSE 工程化

后端：

```java
@GetMapping(value="/chat/stream", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
public Flux<String> chatStream(@RequestParam("msg") String message) {
    return chatClient.prompt().user(message).stream().content();
}
```

前端（浏览器 EventSource，GET）：

```js
const es = new EventSource('/chat/stream?msg=' + encodeURIComponent('你好'));
es.onmessage = (e) => console.log('chunk:', e.data);
es.onerror = () => es.close();
```

> SSE 的好处：浏览器原生支持流式事件，不用自己手搓读流。

## 6.2 也可以：fetch 读流（更灵活）

适合 POST、带鉴权 header 等场景：

```js
const resp = await fetch('/chat/stream?msg=' + encodeURIComponent('你好'));
const reader = resp.body.getReader();
const decoder = new TextDecoder('utf-8');
let result = '';

while (true) {
  const { value, done } = await reader.read();
  if (done) break;
  result += decoder.decode(value, { stream: true });
  console.log(result);
}
```

------

# 7）实战注意点（你真上项目会遇到的坑）

1. **不要用传统 Spring MVC（Tomcat 阻塞）硬上流式**
   能做，但并发高时线程占用严重；WebFlux/Netty 更适合。
2. **返回 String 时可能被缓冲**
   有些代理/网关会缓冲响应导致“看起来不流”。
   解决：SSE、禁用 buffer、合理 flush、网关配置。
3. **正确的 Content-Type 很关键**
   - SSE：`text/event-stream`
   - 普通文本流：`text/plain`
   - 不推荐拿 `text/html` 当通用流（容易被浏览器当 HTML 解析、或被中间层处理）
4. **编码统一 UTF-8**
   服务端、响应头、前端解码都统一 UTF-8，中文才稳。

------

# 8）面试官怎么讲（给你一段可直接背的 1 分钟话术）

> 我们的流式响应基于 WebFlux 的 Reactor。非流式 call 会等模型全部生成后一次性返回，首字延迟高；流式 stream 则把模型生成过程拆成多个 chunk，边生成边返回，显著降低首字延迟提升体验。
> 在实现上，我让 Controller 返回 `Flux<String>`，它表示 0 到 N 个文本片段的异步序列，Spring WebFlux 会订阅这个 Flux，把每个元素按分块写入 HTTP 响应体并及时 flush。
> `produces` 用于声明响应的 Content-Type，例如用 `text/event-stream` 做 SSE 更标准；`charset=UTF-8` 明确响应体编码，避免中文乱码。输入参数的编码由 URL 编码与服务端解码负责，跟 produces/charset 是输出侧概念。

------







