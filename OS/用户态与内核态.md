先给一句“总纲”，把几个概念先串起来：

> **用户态 / 内核态**：CPU 的两种权限等级；
>  **用户空间 / 内核空间**：内存里给“应用代码”和“操作系统内核代码”划的两块区域；
>  运行用户程序时：CPU 用“低权限模式”在用户空间里跑代码；
>  进入内核时：CPU 切成“高权限模式”在内核空间里跑代码。

下面我从硬件 → 内存 → 程序执行流程，一层层讲清楚那句话到底是什么意思。

------

## 1. 从 CPU 角度：什么是“用户态 / 内核态”？

### 1.1 CPU 有不止一种“权限档位”

现代 CPU 不是只有“在跑 / 不在跑”这么简单，它有**不同的特权级**（privilege level），常见说法：

- **内核态（内核模式，Kernel mode、Supervisor mode）**
  - 权限最高；
  - 可以执行一切“危险指令”（访问硬件寄存器、改页表、关中断、操作设备等）。
- **用户态（User mode）**
  - 权限受限；
  - **禁止执行危险指令**，也不能随便读写任意内存，只能动“被允许的那部分”。

这么设计的原因就是：

> 防止一个烂应用把整个系统搞崩，只允许操作系统内核去直接摸硬件和“底层关键资源”。

你可以把它想象成：

- 内核态 = 拿着“系统管理员账号”的状态；
- 用户态 = 普通账号，很多东西没有权限操作。

------

## 2. 从内存角度：什么是“内核空间 / 用户空间”？

### 2.1 每个进程看到的是“虚拟地址空间”

操作系统给**每个进程**一个自己看到的“连续内存世界”——**虚拟地址空间**，比如 0 ~ 4GB（32bit 时代）或更大（64bit）。

在这个虚拟空间里，大致会被划成两块：

- **用户空间 (user space)**：
  - 放用户程序用的东西：
    - 代码段（.text）
    - 数据段、BSS
    - 堆（heap）
    - 栈（stack）
    - mmap 的各种区域
  - 只有这些范围的虚拟地址，在**用户态**下可以访问。
- **内核空间 (kernel space)**：
  - 放操作系统内核的：
    - 内核代码、内核数据结构
    - 内核栈
    - 各种管理结构（进程、文件、socket、缓存等）
  - 只有在**内核态**下才允许访问。

在很多 32 位 Linux 里，会是类似这样（只做示意）：

```text
0x00000000  ----------------------
            |    用户空间          |
            |  用户代码/数据/栈堆  |
            |      ...            |
0xC0000000  ----------------------
            |    内核空间          |
            |  内核代码/数据结构   |
            |      ...            |
0xFFFFFFFF  ----------------------
```

64 位就更大了，但概念一样：**虚拟地址空间逻辑上划分成两块：一块给用户程序，一块给 OS 内核**。

### 2.2 关键点：不是“物理上分开”，而是“权限上分开”

- 用户空间 / 内核空间 是在**虚拟地址级别**划的；
- 每次访问内存，CPU 都会：
  - 用当前的页表，把虚拟地址翻译成物理地址；
  - 再用当前的“模式位”（User / Kernel）决定：
     “你有没有资格访问这个虚拟地址对应的页”
- **用户态时**：如果访问了一个标记为“只有内核能访问”的页 → 触发异常（段错误 segfault）；
- **内核态时**：可以访问所有页（前提是系统自己没做额外限制）。

所以“内核空间”可以理解为：

> 在虚拟地址空间中，那些**被标记为只能在内核态访问的地址区域**。

------

## 3. 那句“内核运行的时候… 用户程序运行的时候…”到底是什么意思？

这句：

> “内核运行的时候，系统以内核态进入内核空间执行。
>  而执行一个普通用户程序的时候，系统将以用户态进入用户空间执行。”

拆开来说就是两件事：

### 3.1 “内核运行的时候，系统以内核态进入内核空间执行”

发生在：

- 系统启动（内核初始化）；
- 或者某个事件触发内核执行，比如：
  - 用户程序调系统调用（`read`、`write` 等）；
  - 硬件中断（网卡、磁盘、时钟等）；
  - 异常（除零、缺页、非法访问等）。

此时过程大致是：

1. CPU 当前在执行用户程序的指令，处于 **用户态**；
2. 程序触发一个“陷入内核”的事件：
   - 执行 `syscall` / `int 0x80`（系统调用指令）；
   - 或者硬件发中断，CPU 收到中断请求；
3. CPU 做几步标准的硬件动作：
   - 自动切换到 **内核态**（特权位改变）；
   - 切换到对应的 **内核栈**；
   - 跳转到一个 **内核入口函数地址**（这个地址在内核空间里，比如某个中断向量表指定的位置）。
4. 然后开始执行内核代码（C 写的、最后变成机器码），这些代码所在的内存区域就是 **内核空间**。

所以，“内核运行的时候，系统以内核态进入内核空间执行” =

> CPU 把自己切到高权限模式，然后去内核地址范围里取指令执行。

------

### 3.2 “执行一个普通用户程序的时候，系统以用户态进入用户空间执行”

反过来，当内核处理完该做的事（比如完成一次 `read`）后，会：

1. 准备好要返回给用户程序的寄存器状态、返回值；
2. 执行一条“从内核返回用户态”的指令（比如 `iret`、`sysret` 之类，具体看架构）；
3. CPU 自动：
   - 把特权级从 **内核态**降回 **用户态**；
   - 恢复用户进程的寄存器状态、用户栈指针等；
   - 跳转回用户代码所在的虚拟地址（用户空间里的某个地址）。

接下来，CPU 再次开始在 **用户空间** 取指令执行（例如你的业务代码、Spring Boot 的 handler）。

所以，“执行一个普通用户程序的时候，系统以用户态进入用户空间执行” =

> CPU 在低权限模式下，只跑用户代码，只能访问用户空间那部分内存。

------

## 4. 再具体一点：一次系统调用的完整跑法

假设你在 Java 里写：

```java
Files.readAllBytes(Path.of("data.txt"));
```

底层大概是：

1. JVM 调用本地库（JNI/Native），最终变成一次系统调用 `read(fd, buf, size)`；
2. 用户态下执行到一条特殊指令，比如：
   - x86_64：`syscall`
3. 硬件动作：
   - CPU 切换到内核态；
   - 切换栈；
   - 跳转到内核里的 `sys_read` 入口地址（在内核空间范围内）。
4. 内核代码 `sys_read`：
   - 检查参数合法性；
   - 找到这个 fd 对应的文件对象；
   - 调度磁盘 / 缓存；
   - 把数据写入用户提供的缓冲区（此时它在内核态，可以“代表这个进程”访问用户空间内存）。
5. 做好之后，调用“返回用户态”的指令：
   - CPU 恢复到原来的用户栈、用户寄存器，模式切回用户态。
6. 回到用户空间里的机器指令，像什么都没发生一样继续跑，只是 `read` 调用现在返回了实际读到的字节数。

这个过程里：

- 在用户代码执行时：用户态 + 用户空间；
- 在内核执行 `sys_read` 时：内核态 + 内核空间；
- **来回切换很多次，速度很快**，你平时写业务代码感受不到。

------

## 5. 用户空间 vs 内核空间 再比喻一下

你可以把一台电脑想成一个大楼：

- **内核空间 = 大楼里的“机房 + 管理室”**：
  - 只有管理员（内核态）能进去；
  - 里面有配电房、网络机柜、核心控制器；
- **用户空间 = 大楼里的各种办公室 / 工位**：
  - 员工（用户程序）在这里干活；
  - 权限有限，看不到也动不了机房里的东西。
- 员工想打印（系统调用）：
   → 填好表单（参数）交给管理员（syscall），管理员进机房操作打印机硬件。
- 员工自己不能直接去摸打印机主板那块芯片（那是内核空间对应的权限级别）。

------

## 6. 再用几句话帮你收个总结

1. **用户态 / 内核态**：
   - 是 CPU 的两种权限级别；
   - 决定当前能不能执行“特权指令”、能访问哪些内存区域。
2. **用户空间 / 内核空间**：
   - 是进程虚拟地址空间的两块区域；
   - 用户空间放程序自己的代码和数据；
   - 内核空间放 OS 内核代码和数据，只能在内核态访问。
3. **那句话的含义**：

> - 执行操作系统内核代码时：
>    CPU 处于内核态，指令从内核空间取；
> - 执行普通应用程序代码时：
>    CPU 处于用户态，指令从用户空间取。

1. 这整套设计的本质目的是：**隔离、保护和安全**
   - 应用崩了，最多干掉自己，不直接毁掉整个系统；
   - 所有危险操作都由内核负责，统一管理访问硬件和关键资源。

如果你愿意，我可以下一步专门讲一下：

- “用户态 → 内核态” 和 “线程上下文切换” 有什么区别？
- 为什么系统调用比普通函数调用慢，但又没想象中那么慢？





# linux中如何体现

你现在的理解其实已经踩到点子上了：

> “是不是就一个状态标志，标志着 CPU 现在能不能访问内核空间？”

大方向是对的，只是**比你想的多两层东西**：

- 硬件有“当前特权级”这类状态（可以理解成“模式位”）；
- 再配合**页表里每一页的权限位**，一起决定当前能不能碰内核空间。

我用 Linux 2.6.34 + x86 来讲一遍，从“硬件怎么区分用户/内核态”到“内核源码哪里用到了这些”。

------

## 1. 基本概念先对齐一下

### 1.1 用户态 / 内核态：CPU 的两种特权等级

在 x86 上，CPU 有 4 个 ring（0~3），Linux 只用：

- **ring 0** → 内核态（kernel mode）
- **ring 3** → 用户态（user mode）

“当前在 ring 几”就是你说的那个“状态标志”的本质之一，
 在 x86 上是由**代码段选择子 CS 的低 2 位**（CPL）体现的：

- `CS & 3 == 0` → ring 0 → 内核态
- `CS & 3 == 3` → ring 3 → 用户态

Linux 内核里判断“是不是从用户态陷入”的典型代码就是用这个：

在较新的内核里，可以看到：

```c
static __always_inline int user_mode(struct pt_regs *regs) {
    return !!(regs->cs & 3);  // cs 低两位非零 => 用户态
}
```

2.6.34 的实现形式略有差别，但思路一样：
 **看陷入时保存下来的 CS 段寄存器的 CPL 位，就知道这次中断/系统调用是来自用户态还是内核态。**

------

### 1.2 用户空间 / 内核空间：进程虚拟地址空间的两块区域

在 32 位 x86 + Linux 2.6 里，一般是经典的 **3G/1G 划分**：

```text
0x00000000  --------------------------
            用户空间 (per-process)
            代码、数据、堆、栈、mmap ...
0xC0000000  --------------------------  PAGE_OFFSET
            内核空间 (对所有进程基本一致映射)
            内核代码、数据结构、内核栈、物理内存映射等
0xFFFFFFFF  --------------------------
```

- 每个进程都有自己的**用户空间部分**（0 ~ 3G），用户态代码能访问；
- 所有进程**共享同一个内核空间映射**（3G ~ 4G），但这个区域在页表里标记为“仅内核可访问”。

页表里的每一页有个 **U/S 位（user/supervisor）**：

- U=1 → 用户态可以访问；
- U=0 → 只有内核态可以访问。

**组合起来就是：**

> 当前 CPU 在“用户态”（CPL=3）时，只能访问 U=1 的页；
>  在“内核态”（CPL=0）时，可以访问 U=0/U=1 的页。

这就把你说的那句完整化了：

> 不只是有一个“状态标志”（当前 CPL），
>  还要配合“每一页的权限标记”（U/S 位）决定能不能访问内核空间。

------

## 2. Linux 2.6.34 里是怎么“用”这个机制的？

### 2.1 系统调用 / 中断入口：从用户态进内核态

以 2.6.34 的 x86-32 为例，系统调用入口在：
 `arch/x86/kernel/entry_32.S` 里，注释就写着：系统调用和异常的底层入口。

关键流程是：

1. 用户态程序在 user space 里跑到 `read()` 这类 libc 函数；
2. libc 最终会发出一条“陷入内核”的指令：
   - 32 位：`int $0x80` 或 `sysenter`
   - 64 位：`syscall`
3. 这条指令是**硬件指令**，CPU 根据 IDT / MSR 的配置：
   - 自动把当前特权级从 CPL=3 切到 CPL=0；
   - 换到内核栈；
   - 跳转到内核空间里的入口地址（比如 `system_call` 那个 label，在 entry_32.S 中）。

此时：

- CPU 已经是 **内核态**；
- 指令地址在 0xC0000000 以上的 **内核空间**；
- 可以安全访问各种内核数据结构、管理页表、调度等。

也就是说：

> “内核运行的时候，系统以内核态进入内核空间执行”
>  = CPU 现在处于 ring0，EIP/CS 指向内核映射的地址范围，
>  硬件允许它访问标记为 supervisor 的页。

------

### 2.2 内核执行完，如何“回”用户态？

当内核执行完系统调用的 C 函数后（比如 `sys_read`），最终会走到汇编里的“返回用户态”逻辑：

- 恢复之前保存的一堆寄存器（从 `struct pt_regs` 里）；
- 执行 `iret` / `sysexit` / `sysret` 之类 *return-from-syscall* 指令。

这些指令会让 CPU：

1. 从栈里弹出新的 `CS:EIP`（指向用户代码）、`SS:ESP`（用户栈）；
2. 同时根据新的 `CS` 段选择子上的 CPL=3，把特权级切回**用户态**。

接下来：

- CPU 又回到用户空间的地址范围里（< 0xC0000000）去取指令；
- 用户代码继续执行，拿到 `read()` 的返回值，好像中间只是调用了个“普通函数”。

这就对应：

> “执行一个普通用户程序的时候，系统将以用户态进入用户空间执行”。

------

### 2.3 源码中“区分用户/内核态”的地方

除了汇编入口，内核里经常要知道：

- “这次异常/系统调用是用户态触发的，还是内核态里自己跑炸的？”

在 x86 上就是利用刚才说的 `CS & 3`：

- 系统调用/中断入口的汇编会先把寄存器保存到一个 `struct pt_regs` 里（内核栈上）；
- C 代码拿到 `struct pt_regs *regs` 后，用 `user_mode(regs)` 判断：
  - 来自用户态 → 这是用户进程的问题；
  - 来自内核态 → 内核自己 bug 了，可能要 oops/panic。

**注意：**

- 这个 `user_mode()` 只是“读状态”的工具，而不是“切换状态”的开关；
- 真正的切换是靠 CPU 执行 `syscall/int/iret/...` 时自动完成的。

------

## 3. “用户空间 / 内核空间”在地址空间上的体现（2.6.34 风格）

配合上面的模式位，再看一次虚拟地址空间的分布：

- `TASK_SIZE`（大概是 3G, 即 0xC0000000）以下：用户空间
  - 页表项里 U=1，用户态可以访问；
  - 每个进程有自己的 `mm->pgd`，这部分映射在不同进程之间不同。
- `PAGE_OFFSET`（同样是 0xC0000000）以上：内核空间
  - 页表项里 U=0，只有 CPL=0 的内核态可以访问；
  - 对所有进程共享同一份映射（内核代码、数据、直接映射物理内存等）。

所以你可以更精确地理解为：

> - CPU 有一个“当前模式位”（CPL），
> - 页表每页有权限位（U/S），
> - Linux 在 2.6.34 里把高地址段的页都设为 U=0，低地址段按需设为 U=1，
> - **两者共同决定：用户态只能碰用户空间，内核态能碰两边。**

------

## 4. 回答你那句“是不是就一个状态标志？”

可以这么说：

- 从 CPU 角度：
   是的，有一个“当前特权级”的状态（在 CS 里），决定你是在用户态还是内核态；
- 但光有这个还不够，**得加上内存页的“权限标签”**（U/S 位）；
- Linux 内核源码做的事情主要是：
  - 启动时：设置 GDT/IDT/MSR，让 `int 0x80/syscall/iret` 这些指令知道要跳到哪去、用哪个栈、切哪个特权级；
  - 建页表时：把内核那一块 VA 都标成 “supervisor only”；
  - 系统调用和中断入口（entry_32.S / entry_64.S）里，配合 `user_mode(regs)` 等宏来判断来自哪里。

**真正切状态的是硬件指令，不是 C 代码里的某个变量：**

- `int 0x80` / `syscall` → 硬件自动从用户态 → 内核态，跳到内核空间入口；
- `iret` / `sysret` → 硬件自动从内核态 → 用户态，回到用户空间。

------

### 一句压缩总结

> 在 Linux 2.6.34 这类内核里，“用户态/内核态”本质是 CPU 的特权级状态（比如 x86 的 CPL），
>  “用户空间/内核空间”是虚拟地址空间里两块用不同权限位映射的区域。
>  内核运行时：CPU 处于内核态，在内核空间地址范围取指；
>  用户程序运行时：CPU 处于用户态，只能在用户空间那一段地址上跑。

如果你愿意，我们可以挑 `arch/x86/kernel/entry_32.S` 里某个系统调用入口（`system_call`）一步一步“跟汇编走”，看它是怎样保存寄存器、切栈、调用 C 函数、再 `iret` 回用户态的，那样会更有 “源码视角下的直观感”。





# 具体实例 getpid

好，我们来“跟着一条系统调用走一圈”。
 选一个最简单的例子：**32 位 Linux 2.6.x 上，用户程序调用 getpid()，通过 int 0x80 进入 ENTRY(system_call)，再 iret 回去。**

> 你之前那句理解其实已经对了一半：
>  内核/用户态确实是 CPU 的一个状态位 + 页表权限配合起来的效果。
>  下面就是“这个状态位在 entry_32.S 里是怎么跑起来的”。

------

## 0. 场景设定：用户代码里的一行 `getpid()`

用户程序：

```c
#include <unistd.h>
int main() {
    pid_t p = getpid();
    return 0;
}
```

glibc 里的 `getpid()` 封装最终会变成类似（简化）：

```asm
movl $__NR_getpid, %eax   ; 把系统调用号放进 eax
int  $0x80                ; 触发软中断，进入内核
; 返回后 eax 里就是 pid
```

此时：

- CPU 在 **用户态（CPL=3）**
- 正在执行位于 **用户空间** 的指令（低地址）

接下来重点是：这条 `int 0x80` 发生了什么。

------

## 1. 从 `int 0x80` 到 `ENTRY(system_call)`

### 1.1 硬件做的事（和内核源码无关）

当执行 `int $0x80` 时，CPU 干了这几件事（x86 规范里的标准流程）：

1. 在 IDT（中断描述符表）里找第 0x80 号描述符；
2. 发现这是一个“陷阱门 / 中断门”，目标是某个内核代码地址，例如 `system_call`；
3. 检查特权级：从 CPL=3 跳到 CPL=0：
   - 切换到当前进程的 **内核栈**（TSS 里保存的 esp0）；
   - 在新栈上依次压入：旧 `SS`、旧 `ESP`、`EFLAGS`、旧 `CS`、旧 `EIP`；
4. 设 CS = 指向内核代码段（ring 0），EIP = `system_call` 的入口地址。

到这一步为止：

- CPU 已经处于 **内核态（ring0）**
- 指令指针已经落在 **内核空间** 的某个地址（`ENTRY(system_call)`）
- 用户态那边的寄存器和栈信息，被保存在内核栈了

这部分动作完全是硬件根据 IDT + 门描述符 + TSS 自动完成的。

------

## 2. `ENTRY(system_call)` 汇编入口在干嘛？

在 Linux 2.6.x 的 `arch/x86/kernel/entry_32.S` 里，关键片段大概是这样（我用白话描述一下）：([is.muni.cz](https://is.muni.cz/el/fi/jaro2011/PV204/um/LinuxRootkits/sys_call_table_complete.htm?utm_source=chatgpt.com))

```asm
ENTRY(system_call)
    RING0_INT_FRAME         # 一些 CFI/栈帧标记，先不用管
    pushl %eax              # 把原来的 eax（系统调用号）压栈，叫 orig_eax
    SAVE_ALL                # 用一堆 push 指令把所有通用寄存器、段寄存器等压栈，形成 struct pt_regs
    GET_THREAD_INFO(%ebp)   # 通过当前 esp 找到 thread_info / current
    testl $_TIF_WORK_SYSCALL_ENTRY, TI_flags(%ebp)
    jnz  syscall_trace_entry # 如果有 trace/ptrace 等特殊标志，走调试路径
    cmpl $(NR_syscalls), %eax
    jae  syscall_badsys      # eax >= NR_syscalls → 号非法，返回 -ENOSYS

syscall_call:
    call *sys_call_table(,%eax,4)  # 根据 eax 下标调用对应的 sys_xxx 函数
    movl %eax, PT_EAX(%esp)        # 把返回值写入内核栈上的 pt_regs->eax（留给用户态）
syscall_exit:
    ...
    jmp  restore_all
ENDPROC(system_call)
```

重点解释几个东西：

### 2.1 `SAVE_ALL`：把用户态寄存器收集成 `struct pt_regs`

`SAVE_ALL` 是个宏，大致就是连续 `pushl`：

- `pushl %eax`（刚才已经手动 push 了一次 orig_eax）
- `pushl %ebx`
- `pushl %ecx`
- ...
- `pushl %ds`、`pushl %es` 等

压完之后，**内核栈顶这坨数据**就是一个连续的结构体布局，内核里叫 `struct pt_regs`，里面存着：

- 用户态的 EIP / CS / EFLAGS / ESP / SS
- 用户态的通用寄存器

之后 C 代码（比如 `sys_read`）如果要拿到这次调用的寄存器，可以通过这个 `pt_regs` 结构访问。

你可以理解为：

> `SAVE_ALL` = 把“用户态 CPU 状态”打包成一个结构体压在栈上，方便 C 层使用和恢复。

------

### 2.2 `sys_call_table`：从系统调用号跳到真正的内核函数

`eax` 里是系统调用号，比如 `__NR_getpid`，对应表里的一个条目：

- `sys_call_table[__NR_getpid] = sys_getpid;`([Stack Overflow](https://stackoverflow.com/questions/10060458/how-can-i-find-where-syscall-some-number-routine?utm_source=chatgpt.com))

这一句：

```asm
call *sys_call_table(,%eax,4)
```

意思就是：

> “从 sys_call_table 数组里取第 eax 个函数指针，call 它”

所以这一步就跳进了 C 函数：

```c
asmlinkage long sys_getpid(void)
{
    return task_tgid_vnr(current);
}
```

- `current` 指向当前进程的 task_struct；
- `task_tgid_vnr` 取出进程号并返回（放在 eax）。

当 `sys_getpid` 返回时：

- 返回值在 eax；
- 这时还在 **内核态**，在 **内核空间** 里执行。

然后：

```asm
movl %eax, PT_EAX(%esp)
```

这句很关键：

- `PT_EAX(%esp)` 是 `pt_regs` 结构里 `eax` 字段的偏移；
- 把返回值写回到“保存用户态寄存器的那块 pt_regs 里”。

为什么要写在那？
 因为**后面恢复寄存器时，会从这个结构体把值 pop 回真正的 eax 寄存器**，从而让用户态在 `getpid()` 返回后看到正确的返回值。

------

## 3. `restore_all` + `iret`：从内核态回到用户态

`system_call` 结尾跳到 `restore_all` 附近（略掉了调度、信号等复杂逻辑）：([android.googlesource.com](https://android.googlesource.com/kernel/x86_64/%2B/refs/heads/android-x86_64-fugu-3.10-marshmallow-mr1/arch/x86/kernel/entry_32.S?utm_source=chatgpt.com))

```asm
restore_all:
    ...
restore_nocheck:
    RESTORE_REGS 4    # 把刚才 SAVE_ALL 压栈的寄存器依次弹回
irq_return:
    iret              # 硬件指令，切回用户态
```

### 3.1 `RESTORE_REGS`：按 `pt_regs` 布局恢复寄存器

- 这又是一个宏，里面就是一串 `popl`：
  - 先恢复通用寄存器：`popl %edi`, `popl %esi`, ...，包括刚才被我们改过返回值的 `%eax`；
  - 再恢复段寄存器；
  - 最后恢复 `EIP/CS/EFLAGS/ESP/SS` 等（这里配合 `iret` 来做）。

简单理解：

> `RESTORE_REGS` 把之前 `SAVE_ALL` 压栈的那一整坨内容“倒着”弹回寄存器，
>  让 CPU 的寄存器状态回到“看起来像是从用户空间的某个位置继续执行”的样子。

关键点：

- 因为我们提前把 sys_getpid 的返回值写到 `pt_regs.eax` 里；
- 所以这时候弹出来的 `%eax` 已经是 **pid** 了。

------

### 3.2 `iret`：真正从内核态跳回用户态

`RESTORE_REGS` 跑完，栈顶就剩下最早被硬件压入的那几项：

- 用户态的 EIP
- 用户态的 CS（CPL=3）
- 用户态的 EFLAGS
- 用户态的 ESP
- 用户态的 SS

`iret` 会：

1. 从栈中弹出 EIP、CS、EFLAGS、ESP、SS；
2. 检查 CS 的 CPL=3 → 特权级从内核态（ring0）切回用户态（ring3）；
3. 切回用户栈；
4. 接着在用户空间执行刚才那条 `int 0x80` 之后的下一条指令。

对用户程序来说：

```c
pid_t p = getpid();
```

- 执行完后，`p` 的值就是当时内核里 `sys_getpid()` 返回的那个值；
- 它根本不知道中间发生过：特权级切换、`SAVE_ALL`、`sys_call_table`、`sys_getpid`、`RESTORE_REGS`、`iret` 这一大堆戏。

------

## 4. 把整个流程压成一张“时间线”

用一个时间顺序帮你再串一次：

1. **用户空间 / 用户态**

   - 指令：`mov $__NR_getpid, %eax; int $0x80`
   - CPU 在用户空间地址范围取指，CPL=3。

2. **int 0x80（硬件）**

   - 查 IDT → 跳转到 `system_call`；
   - 切换到内核栈；
   - 保存用户 CS/EIP/SS/ESP/EFLAGS 到内核栈；
   - CPL 从 3 → 0，进入内核态。

3. **ENTRY(system_call)（汇编）**

   - `push %eax`：保存 syscall 号；
   - `SAVE_ALL`：把所有寄存器压栈，形成 `pt_regs`；
   - `GET_THREAD_INFO`：找到当前进程；
   - 检查 trace / seccomp 等标志；
   - 检查 syscall 号是否合法；
   - 根据 `sys_call_table[eax]` 调用 `sys_getpid`。

4. **sys_getpid()（C 函数）**

   - 读取 `current->tgid`；
   - 返回，放在 `%eax`。

5. **回到 system_call（汇编）**

   - `mov %eax, PT_EAX(%esp)`：写进 `pt_regs.eax`；
   - 处理信号、调度等（略）；
   - 跳到 `restore_all`。

6. **restore_all + iret**

   - `RESTORE_REGS`：按 `pt_regs` 弹出寄存器（包括带 pid 的 `%eax`）；
   - 栈顶是保存的用户 EIP/CS/EFLAGS/ESP/SS；
   - `iret`：切回 CPL=3，跳回用户代码。

7. **回到用户空间 / 用户态**

   - 用户代码继续执行：

     ```c
     pid_t p = getpid(); // 此时 eax/p 已是 pid
     ```

   - 看起来就像调用了一个普通函数。

------

## 5. 和你最初的问题做个呼应

> “用户态 / 内核态 是不是就是一个状态标志，标志 CPU 能访问内核空间还是用户空间？”

更精确一点说：

- 是的，CPU 确实有一个“当前特权级”（CPL）这种状态（可以类比成一个标志位）；
- 但 CPU 能不能访问“内核空间”，还要配合：
  - 页表中每一页的 U/S 权限位（用户/特权）；
- `int 0x80` / `iret` / `syscall` / `sysret` 等指令，负责**硬件层面切换这个特权级状态**，并配合栈和 CS/SS/ESP 等寄存器完成“从用户空间 → 内核空间， 再从内核空间 → 用户空间”的跳转；
- `entry_32.S` 里的 `ENTRY(system_call)` / `SAVE_ALL` / `sys_call_table` / `RESTORE_REGS` / `INTERRUPT_RETURN(=iret)`，就是**内核在这个硬件基础上，把一次系统调用“包装成一个正常的 C 调用/返回”的具体实现。**

------

如果你愿意，下一步我们可以挑一个“带参数”的系统调用（比如 `write(fd, buf, len)`），看一下参数是怎么从用户栈 / 寄存器进到 `sys_write` 的（涉及调用约定、pt_regs 里各寄存器对应关系）。这样你对“系统调用 ABI”会更有完整印象。

