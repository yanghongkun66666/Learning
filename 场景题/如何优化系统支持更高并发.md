## 1) 先把几个核心概念讲清楚（不清楚这些，优化很容易跑偏）

### 并发（Concurrency）

同一时间系统“在处理中的请求数”。比如有 200 个请求正在执行（有的在算、有的在等数据库、有的在等磁盘），并发就是 200。

### 吞吐（Throughput）

单位时间完成的请求量：常见是 **QPS/TPS**

- QPS：每秒请求数（多用于读）
- TPS：每秒事务数（多用于写/事务）

### 延迟（Latency）

一个请求从进来->返回所花时间。关注：

- 平均（mean）
- P95 / P99（尾延迟，最关键）

### 容量关系：Little’s Law（非常实用）

**并发数 ≈ 吞吐(QPS) × 平均响应时间(秒)**

例子：
如果 QPS=1000，平均响应时间=0.2s
并发≈1000×0.2=200

所以并发上不去，可能不是“线程不够”，而是**响应时间太长**或**吞吐被瓶颈卡住**。

### 瓶颈的本质

系统吞吐取决于**最慢/最紧的那一段**（CPU、锁、网络、数据库、磁盘、外部服务……）。
优化就是：**找瓶颈→打通瓶颈→再找下一个瓶颈**（迭代）。

------

## 2) 并发“上不去”的常见原因（按层次拆开看）

把系统看成链路：

**客户端 → 网络/网关/LB → 应用服务 → 缓存 → 数据库/存储 → 外部依赖**

并发上不去通常来自以下几类：

### A. 应用层瓶颈（最常见）

- **线程/协程模型不匹配**：大量 I/O 等待却用阻塞线程；线程开太多导致上下文切换爆炸
- **连接池太小**：DB/Redis/HTTP 连接池限制了同时在飞的请求
- **锁竞争**：全局锁、热点 key 锁、队列锁、日志锁
- **GC/内存抖动**：频繁分配、对象过大、堆设置不合理
- **同步调用链太长**：每个请求串行调用多个服务，尾延迟被叠加

### B. 数据库/存储瓶颈（非常典型）

- **慢查询/缺索引/扫描大表**
- **写入放大**：频繁 update/事务过大/日志刷盘频繁
- **连接数/并发事务上限**：DB 自身处理并发有限
- **热点行/热点分区**导致锁等待
- **磁盘 IOPS/吞吐不足**（尤其写）

### C. 缓存失效或缓存穿透

- 缓存命中率低导致请求全部打到 DB
- 热点 key 过期造成“缓存击穿”
- 不存在的 key 大量请求导致穿透

### D. 网络/流量瓶颈

- **带宽打满**（Gbps）
- **PPS 打满**（每秒包数，尤其小包多）
- LB/Nginx 连接数、accept 队列、ephemeral port 耗尽
- TLS 握手开销（没复用连接）

### E. 外部依赖瓶颈

你自己扛得住，但下游（第三方接口/支付/搜索）扛不住，导致你这边堆积。

------

## 3) 一套“从定义到落地”的优化路线

### 第 0 步：明确目标（不明确会乱优化）

- 目标 QPS/TPS？
- 允许的 P95/P99 延迟？
- 读写比例？峰值持续多久？
- 是否允许降级？一致性要求？

### 第 1 步：把可观测性补齐（没有数据就等于摸黑）

至少要有：

- **四个黄金指标**：吞吐、延迟、错误率、饱和度（CPU/IO/队列）
- 分层指标：应用、DB、缓存、网络、下游
- **链路追踪**：每个请求时间花在哪（DB/缓存/远程调用/业务逻辑）
- Profiling（CPU/内存/锁/GC）

> 很多“并发上不去”的真实原因，一看 tracing 就暴露：比如 80% 时间在等 DB。

### 第 2 步：先用压测定位瓶颈（再优化）

正确姿势是：逐步加压，观察哪个指标先“拐头/打满”：

- CPU 100%？（算力瓶颈）
- Load average 高但 CPU 不高？（I/O 等待）
- DB 慢查询飙升？（存储瓶颈）
- 网卡带宽/PPS 打满？（流量瓶颈）
- 错误率先上升？（连接池、限流、下游崩）

### 第 3 步：按收益从大到小优化（常见排序）

我给你一个“最常见最有效”的顺序：

#### ① 先减请求成本（最快见效）

- 业务逻辑剪枝：少算、少查、少调用
- 合并请求、批量查询、避免 N+1 查询
- 压缩响应、只返回必要字段
- 复用连接（HTTP keep-alive/连接池）

#### ② 再上缓存（把 DB 从热点中救出来）

- 本地缓存（进程内）适合热点小数据
- Redis/Memcached 适合共享缓存
- 缓存策略：
  - **Cache-Aside**（最常用）
  - 热点 key 永不过期 + 异步刷新
  - 防击穿：互斥锁/单飞（singleflight）
  - 防穿透：布隆过滤器/空值缓存
  - 防雪崩：过期时间加抖动

#### ③ 再做“读写分离/分片/索引/慢查询治理”

- 为关键查询加索引（以及覆盖索引）
- 慢查询分析：减少扫描行数、避免大排序
- 读多：加只读副本、读写分离
- 数据量大：按业务维度分库分表（分片）
- 写多：减少事务范围、批量写、异步化（见下一条）

#### ④ 再做异步化/削峰填谷（高并发系统标配）

把“必须立即完成”的事留在同步链路里，其它都扔到队列：

- MQ/Kafka/RabbitMQ：异步写、日志、通知、计算任务
- 好处：削峰、提高前台吞吐、保护 DB
- 必须配：重试、幂等、死信队列、延迟队列、回溯

#### ⑤ 再做限流/熔断/降级（让系统“可控地慢/可控地拒绝”）

- 限流：令牌桶/漏桶（按用户、IP、接口）
- 熔断：下游慢/错就快速失败
- 降级：返回缓存/默认值/减少功能
- 过载保护：队列长度、线程池隔离、backpressure

#### ⑥ 最后再扩容（横向扩展）

- 应用层：无状态化 + 多实例 + LB
- DB/存储：分片/副本/更强机器（DB 横向更难）
- 网络：更高带宽、更强 LB

------

## 4) “并发上不去”时，从哪方面优化？——给你一张排查地图

你可以按这个顺序排（几乎不会走弯路）：

### 1）先看应用端：是否“在等”

- CPU 是否高？
  - CPU 高：算法/序列化/加密/正则/JSON 解析？→ profiling
- CPU 不高但延迟高：
  - 看线程栈/trace：是不是在等 DB/Redis/HTTP？
- 线程池队列是否堆积？
- 连接池（DB/Redis/HTTP）是否耗尽？
- 锁等待是否明显？

### 2）再看 DB：是否被打爆

- 慢查询数量、平均耗时、扫描行数
- 活跃连接数、锁等待、事务时间
- buffer cache 命中率、IO 等待

### 3）再看缓存：命中率与热点

- 命中率低→DB 压力必然上来
- 热点 key 是否击穿/雪崩
- 缓存网络/连接是否成瓶颈

### 4）再看网络/网关/LB

- 带宽利用率是否接近上限？
- PPS 是否高（小包多）？
- Nginx/LB 连接数、accept backlog、TIME_WAIT 激增？
- TLS 是否复用？

### 5）最后看下游依赖

- 下游延迟、错误率、超时重试风暴
- 是否需要熔断/降级/隔离

------

## 5) 你问的重点：存储瓶颈 vs 流量瓶颈怎么理解？

### 存储瓶颈（Storage bottleneck）

“请求主要卡在**读写数据**上”，典型表现：

- DB 慢、磁盘 I/O wait 高
- IOPS 打满（大量随机读写）
- 写入延迟高（刷盘/事务日志）
- 索引/排序导致磁盘访问暴涨

直观类比：
**仓库取货速度跟不上**，货架（磁盘/DB）翻货太慢。

常见解决法：

- 缓存提高命中率，减少读
- 索引/查询优化，减少扫描
- 分库分表、读写分离
- 异步写、批量写、减少事务
- 升级存储（SSD/NVMe）、调 DB 参数（buffer pool 等）

### 流量瓶颈（Traffic / Network bottleneck）

“请求主要卡在**传输/连接处理**上”，典型表现：

- 网卡带宽接近上限（bps）
- PPS 接近上限（包太多）
- 连接数上限、端口耗尽、TIME_WAIT 多
- 网关/LB CPU 高（TLS/转发）

直观类比：
**高速公路堵了**，车（数据包）过不去/收费站（LB）处理不过来。

常见解决法：

- 压缩响应、减少返回字段
- CDN/边缘缓存（静态资源/可缓存接口）
- 连接复用（keep-alive）、HTTP/2/3（看场景）
- 增加带宽、升级 LB、分地域/多机房
- 限流/防刷减少无效流量

### 一个快速判断技巧

- **存储瓶颈**：CPU 可能不高，但 I/O wait 高；DB/磁盘指标先满；trace 显示大量时间在 DB
- **流量瓶颈**：网卡/连接/LB 指标先满；即便后端很快，入口也“进不来/出不去”

------

## 6) 给你一个“落地模板”：高并发系统常用架构组合

如果你要把系统做得“能抗高并发 + 可控”，非常常见的组合是：

1. **入口**：CDN + WAF + 限流
2. **网关/LB**：连接复用、超时、熔断、灰度
3. **应用层**：无状态化、水平扩展、线程池隔离
4. **缓存层**：热点缓存 + 防击穿/雪崩机制
5. **数据层**：索引治理 + 读写分离 + 分片（必要时）
6. **异步层**：MQ 削峰、异步任务、最终一致
7. **可观测**：指标+日志+trace+告警

------

## 7) 你可以立刻用的“实战清单”（并发上不去先做哪几件事）

如果你现在就要提升并发，通常优先做这 8 条（按收益排序）：

1. 上 tracing，找链路里最耗时的 1-2 个点
2. 治理慢查询（索引/SQL/扫描行数）
3. 上缓存并把命中率拉上去（防击穿/雪崩）
4. 把非关键写改成异步（MQ/任务队列）
5. 连接池与线程池调优（避免耗尽与排队）
6. 限流 + 熔断 + 降级（先保住核心接口）
7. 减少响应体积（字段裁剪/压缩）
8. 水平扩容应用实例（前提是无状态）

