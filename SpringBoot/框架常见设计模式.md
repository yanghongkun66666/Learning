可以把这个问题理解成两部分：

1. **Spring / Spring Boot 框架内部大量用到的设计模式**
2. **我们在日常业务开发中，会顺手用（或者已经在用但没意识到）的设计模式**

我按「**创建型 → 结构型 → 行为型**」给你捋一遍，每个都举 **SpringBoot 里的典型例子 + 业务开发中的用法**，你能直接对上号。

------

## 一、创建型模式

### 1. Singleton 单例模式（最常见）

**在 Spring 里：**

- Spring Bean 默认就是 **单例作用域**：`@Service @Component @Repository` 默认都是 **一个容器一个实例**。
- Spring 帮你解决：
  - 多线程安全（大多数 Bean 是无状态的）
  - 生命周期管理（创建 / 销毁）

**平时你是怎么用的？**

```java
@Service
public class UserService {
    // 这个在整个应用里基本就一个实例
}
```

你只写一行 `@Service`，实际上底层帮你搞了一个高质量的单例。

------

### 2. Factory Method / Abstract Factory 工厂模式

**在 Spring 里：**

- `BeanFactory` / `ApplicationContext` 本质上就是 **超级工厂**：
  - 你只要 `context.getBean(UserService.class)`，它就帮你把对象「造出来并装配好」。
- `FactoryBean<T>`：是 Spring 提供的一个扩展点，让你自己定义**如何创建某个 bean**，相当于“工厂中的工厂”。

**平时你是怎么用的？**

- 基本不写 `new`，而是：

```java
@Autowired
private UserService userService;
```

你是在 **用 Spring 的 IoC 容器这个大工厂** 来拿对象，而不是自己 new。

------

### 3. Builder 构建者模式

**在 Spring 体系中：**

- `BeanDefinitionBuilder` 构建 Bean 定义
- 很多配置类用链式构建

**平时代码里：**

- 常见的：Lombok 的 `@Builder`，或者手写 Builder

```java
User user = User.builder()
                .id(1L)
                .name("Tom")
                .age(18)
                .build();
```

这个就是标准的 Builder 模式。

------

## 二、结构型模式

### 4. Proxy 代理模式（跟 AOP / 事务 强相关）

**在 Spring 里：**

- `@Transactional`、`@Async`、`@Cacheable`、AOP 切面，本质都是通过 **代理对象** 实现的：
  - 有接口 → JDK 动态代理
  - 没接口 / 强制用类代理 → CGLIB 生成子类代理

调用流程变成：

```text
调用的是代理对象 → 代理里先执行切面逻辑 → 再调原始目标方法
```

**平时你是怎么用的？**

```java
@Service
public class OrderService {
    @Transactional
    public void createOrder(...) { ... }
}
```

你以为调的是 `OrderService`，其实是调的 `OrderService` 的代理对象，这就是典型代理模式。

------

### 5. Adapter 适配器模式

**在 Spring MVC 里特别典型：**

- `HandlerAdapter`：把各种形式的 handler（Controller 方法、注解形式、老式 Controller）适配成统一的调用接口。
- `HandlerMethodArgumentResolver`：适配不同参数类型（`@RequestParam`、`@PathVariable`、`@RequestBody`）。

**日常开发里的例子：**

- 用第三方 SDK 不好用，自己包一层 Service，提供更「业务友好」的方法 → 你就在实现一个「本地的适配器」。

------

### 6. Facade 外观模式

**在 Spring 里：**

- `JdbcTemplate`、`RestTemplate`、`RedisTemplate`：
  - 把底层连接管理、异常处理、资源释放等复杂细节统一封装成一套简单 API；
  - 对你来说就是一个“门面”，背后帮你 orchestrate 很多组件。

**日常开发：**

- 写一个 `UserFacade` / `OrderFacade`，里面组合了多个 Service 调用，对上层只暴露一个简单方法：

  ```java
  public class OrderFacade {
      @Autowired OrderService orderService;
      @Autowired InventoryService inventoryService;
      @Autowired PaymentService paymentService;
  
      public void createOrderAndPay(...) { ... } // 一口气调一堆内部服务
  }
  ```

  这就是应用层封装的一个门面。

------

### 7. Decorator 装饰器模式（增强而不改变原有接口）

**在 Spring 中：**

- 比较典型的一个例子：`HttpServletRequestWrapper`、`HttpServletResponseWrapper`
  - 增强请求/响应对象，但仍然暴露同样的接口。

**你自己可以这样用：**

- 比如包装一个已有的 Service，让它执行前后多做点事情，但对外依然是同一接口。

```java
public class UserServiceLogDecorator implements UserService {
    private final UserService target;
    public UserServiceLogDecorator(UserService target) { this.target = target; }

    @Override
    public User findById(Long id) {
        log.info("findById {}", id);
        return target.findById(id);
    }
}
```

（AOP 比 Decorator 更常用，但装饰器在一些库封装里也很常见。）

------

## 三、行为型模式

### 8. Template Method 模板方法模式

**在 Spring 里：**

- 所有 `*Template` 命名的基本都带有模板方法思想：
  - `JdbcTemplate`：固定增删改查流程，你传入 SQL + 参数 + RowMapper；
  - `RestTemplate`：固定 HTTP 调用流程，你只传 URL + Method + Body。
- Spring Security 中的一些过滤器链也有类似“模板方法 + 钩子”的结构。

**你自己写代码的典型用法：**

- 比如写一个抽象基类，把流程固定，子类只实现差异部分：

```java
public abstract class AbstractFileProcessor {

    public final void process(String path) {
        before(path);
        doProcess(path);   // 由子类实现
        after(path);
    }

    protected void before(String path) {}
    protected void after(String path) {}
    protected abstract void doProcess(String path);
}
```

这就是标准的 Template Method —— 「流程一定，步骤实现由子类决定」。

------

### 9. Strategy 策略模式

**在 Spring 中：**

- 很多扩展点本质上就是“策略”：
  - `ViewResolver` 不同策略解析视图；
  - `HandlerExceptionResolver` 多种异常处理策略；
  - `Converter`、`Validator` 等等。

**日常开发中非常常见**：

比如按不同类型选择不同处理方式：

```java
public interface PayStrategy {
    void pay(PayRequest req);
}

@Service("wechatPay")
public class WechatPayStrategy implements PayStrategy { ... }

@Service("aliPay")
public class AliPayStrategy implements PayStrategy { ... }
```

再配合 Spring 注入和 `@Qualifier`：

```java
@Autowired
private Map<String, PayStrategy> payStrategyMap;

public void pay(String channel, PayRequest req) {
    PayStrategy strategy = payStrategyMap.get(channel);
    strategy.pay(req);
}
```

这就是典型的策略模式 **+ Spring 自动收集实现类**。

------

### 10. Observer 观察者模式（发布/订阅）

**在 Spring 中：**

- `ApplicationEvent` / `ApplicationListener`：
  - 你发布一个事件 `applicationContext.publishEvent(new UserCreatedEvent(...))`
  - 所有监听这个事件的 Listener 都会被回调。

这就是标准的**观察者模式** + 事件机制。

**常用场景：**

- 用户注册成功后：
  - 发欢迎短信
  - 发优惠券
  - 写审计日志
     不想全写在一个 Service 方法里，就拆成多个 Listener，互不影响。

------

### 11. Chain of Responsibility 责任链模式

**在 Spring 中：**

- Spring Security 的 **FilterChain**；
- Spring MVC 中的 `HandlerInterceptor` 链；

流程：请求进来 → 依次经过一串过滤器/拦截器 → 最后到 Controller → 再反向返回。

**日常开发：**

- 比如写一个“业务处理管道”，按顺序执行多个 Handler：

  ```java
  public interface Handler {
      boolean handle(Context ctx);
  }
  ```

  然后用 List 存一堆 Handler，挨个执行，遇到 false 就中断。

------

## 四、再提一个：IoC / DI 本身常被视为一种“控制反转模式”

虽然严格说 IoC / DI 更像一种架构思想，但很多人会把它和设计模式一起讲，因为它极大改变了代码结构。

**在 Spring 中：**

- 你把依赖交给容器注入，而不是在类中自己 `new`；
- 控制权从“你 new 别人” → 变成“别人把依赖塞给你”。

这背后会顺带引出：

- 单例模式
- 工厂模式
- 依赖倒置原则（DIP）

------

## 五、可以对面试官怎么说（简短版总结）

> 在 Spring Boot 和日常开发里，用得最多的设计模式主要有：
>
> - **创建型**：
>   - 单例（Spring Bean 默认单例）
>   - 工厂（BeanFactory / ApplicationContext 就是大工厂）
>   - Builder（Lombok @Builder 等）
> - **结构型**：
>   - 代理（Spring AOP、@Transactional、@Async、@Cacheable）
>   - 适配器（HandlerAdapter、各种 *Adapter）
>   - 外观（JdbcTemplate、RestTemplate、RedisTemplate）
>   - 装饰器（各种 Wrapper，例如 HttpServletRequestWrapper）
> - **行为型**：
>   - 模板方法（各种 *Template 固定流程 + 回调）
>   - 策略（多实现注入 + Map<String, Strategy>，按类型路由）
>   - 观察者（ApplicationEvent / Listener 事件机制）
>   - 责任链（FilterChain、HandlerInterceptor）
>
> 再加上 IoC/DI 这种控制反转思想，把这些模式串在一起，大大降低了业务代码的复杂度和重复度。

如果你愿意，我可以帮你选 2–3 个在面试中**最容易被问到的模式**（比如：策略 + 模板方法 + 责任链），每个写一个简单 Java 示例，顺便告诉你怎么用“项目经历”的口吻讲出来。