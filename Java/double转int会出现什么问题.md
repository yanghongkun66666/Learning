在 Java 里把 `double` 转成 `int`（比如 `(int) d`）会发生**“窄化转换（narrowing primitive conversion）”**。它不是四舍五入，而是 JVM 按非常固定的底层规则做一次“截断/夹紧”。

------

## 1）最直观的问题：小数部分直接丢掉（截断，向 0 靠近）

```java
(double) 3.9  -> (int) 3
(double) 3.0  -> (int) 3
(double) -3.9 -> (int) -3   // 注意：不是 -4
```

**关键点：不是 floor，也不是 round，而是“向 0 截断”**

- `floor(-3.9) = -4`
- 但 `(int)-3.9 = -3`

所以如果你以为负数会“向下取整”，会出 bug。

------

## 2）范围问题：超出 int 能表示的范围，会“夹紧”到边界（不会报错）

`int` 是 32 位有符号整数，范围是：

- 最小：`-2147483648`（`Integer.MIN_VALUE`）  1000….0000  补码存储，最高位权重  -2^31次方   其他位2^i
- 最大：` 2147483647`（`Integer.MAX_VALUE`）    0111….1111   补码存储

当 `double` 太大或太小：

```java
(double) 1e20   -> (int) 2147483647   // 夹到 MAX
(double) -1e20  -> (int) -2147483648  // 夹到 MIN
```

**这点很坑**：它**不抛异常**，你可能悄悄得到一个边界值，然后后续计算全错还不好排查。

------

## 3）特殊值：NaN / Infinity 转 int 的结果非常“反直觉”

IEEE 754 的 `double` 里有特殊值：

- `NaN`（Not a Number）
- `+Infinity`
- `-Infinity`

Java 的规则是：

```java
(int) Double.NaN          == 0
(int) Double.POSITIVE_INFINITY == 2147483647
(int) Double.NEGATIVE_INFINITY == -2147483648
```

这也是“不会报错但很危险”的来源之一。

------

## 4）更底层：为什么会这样？因为 double 和 int 的存储方式完全不同

### int（32 位补码）

`int` 是一个**精确**的二进制整数，32 位补码表示。  内存里就是 32 个 0/1。

负数的补码 = 绝对值二进制 **取反** + **加 1**   

### 为什么用补码？（底层好处）

- **加法电路统一**：正数负数都用同一个加法器做加法
- 只有一个 0（不会有 +0/-0）
- 溢出规律更简单





### double（64 位 IEEE 754 浮点数）

`double` 由三部分组成：

- 1 位：符号位 sign
- 11 位：指数 exponent
- 52 位：小数部分 fraction（再加上一个隐含的 leading 1，所以有效精度是 **53 位**）
- double 就是在存“符号 + 指数 + 53 位有效数字”。

所以 `double` 能表示很大范围的数，但**精度是有限的**：只有大约 15~16 位十进制有效数字。**double 只有 53 位二进制有效数字**，它能表示的“信息量”有限，所以很多十进制小数只能近似存储。

------

## 5）精度坑：很多“看起来是整数”的 double，其实不精确

比如最经典的：

```java
double d = 0.1 + 0.2; // 结果不是精确的 0.3
System.out.println(d); // 0.30000000000000004
System.out.println((int)d); // 0
```

以及这种更隐蔽的：

```java
double d = 1.9999999999999998;
(int)d == 1  // 你以为是 2？其实截断后是 1
```

原因：很多十进制小数在二进制里是无限循环小数，double 只能存近似值。

因为十进制 0.1 在二进制里是无限循环小数：

0.1=0.00011001100110011...(无限循环)

而 double 的 F 只有 52 位（加上隐含 1 一共 53 位有效数字），只能截断/舍入，导致存进去的是“最接近的那个二进制数”，不是精确的 0.1。

double 可以保证 **2^53 以内的每个整数都能精确表示**；超过 2^53，就不能保证“每个整数都有对应的 double”。

------

## 6）“大整数”坑：double 只能保证 2^53 以内的整数精确

`double` 的有效精度是 53 个二进制位，所以：

- 当整数 **≤ 2^53（约 9e15）** 时，double 可以精确表示每一个整数
- 当整数 **> 2^53** 时，double 只能“跳着表示”（相邻可表示整数之间间隔变大）

例子（概念上）：

- 在很大数附近，double 可能“每次只能表示偶数/每 4 个取一个/每 8 个取一个…”

这会导致：你以为 d 是某个精确整数，实际它早就被舍入到了另一个整数上，然后转 int 时结果出乎意料（当然如果已经超出 int 范围，还会被夹紧）。

------

## 7）JVM 层面到底做了什么？

在字节码里 `double -> int` 对应指令：**d2i**
它执行的就是上面那套规则：

- NaN → 0
- 超范围 → MAX/MIN
- 其余 → 向 0 截断

也就是说，这是 JVM 规范规定的行为，不是“某个编译器碰巧这样实现”。

------

## 8）你在业务/面试里怎么用一句话讲清楚？

你可以这么说（很稳）：

> Java 中 `(int)double` 是窄化转换：先处理特殊值（NaN→0，±Infinity→边界），再对可表示范围内的值**向 0 截断**；超过 int 范围会**夹紧到 Integer.MAX/MIN**，不会抛异常。另外 double 受 IEEE754 精度限制，很多十进制小数无法精确表示，会导致截断结果出现意料之外的偏差。

------

## 9）实际开发建议（避免踩坑）

- 需要四舍五入：用 `Math.round(d)`（返回 long）或 `BigDecimal`
- 需要向下取整：`(int)Math.floor(d)`
- 需要向上取整：`(int)Math.ceil(d)`
- 金额/精确小数：用 `BigDecimal`，不要用 double

------

如果你愿意，我可以再给你一组**“必踩坑演示小例子”**（5~8 个），你在 IDE 里一跑就能直观看到 NaN、Infinity、负数截断、0.1+0.2、超范围夹紧等现象。你想要吗？