## 0. 先把泛型的核心一句话讲清楚

**泛型 = 在编译期给类型加“约束”和“提示”，让你少写强转、少踩 ClassCastException，并让 API 更通用。**

它最关键的副作用（也最常考）是：

### **Java 泛型是“类型擦除”（Type Erasure）**

- 编译后 `List<String>`、`List<Integer>` 在运行时都变成 `List`（同一个 class）
- 所以 **运行时拿不到 T 的真实类型**
- 直接带来一堆限制：`new T()`、`new T[]`、`instanceof List<String>` 都不行（后面会解释）

------

## 1. 最基础：泛型类 / 泛型接口 / 泛型方法

### 1.1 泛型类：Box

- `T` 是“类型占位符”，用的时候再替换成 `String / Integer / User ...`

```java
public class Demo01_Box {
    static class Box<T> {
        private T value;
        public Box(T value) { this.value = value; }
        public T get() { return value; }
        public void set(T value) { this.value = value; }
    }

    public static void main(String[] args) {
        Box<String> b1 = new Box<>("hello");
        String s = b1.get(); // 不需要强转
        System.out.println(s);

        Box<Integer> b2 = new Box<>(42);
        int x = b2.get();
        System.out.println(x);
    }
}
```

### 1.2 泛型接口：Converter<S, T>（业务中非常常见）

```java
public class Demo02_Converter {
    interface Converter<S, T> {
        T convert(S source);
    }

    public static void main(String[] args) {
        Converter<String, Integer> toInt = Integer::parseInt;
        System.out.println(toInt.convert("123") + 1);
    }
}
```

### 1.3 泛型方法：`<T> T first(List<T>)`

泛型方法的 `<T>` 写在返回值前面：

```java
import java.util.*;

public class Demo03_GenericMethod {
    static <T> T first(List<T> list) {
        return list.get(0);
    }

    public static void main(String[] args) {
        System.out.println(first(List.of("a", "b")));
        System.out.println(first(List.of(1, 2, 3)));
    }
}
```

------

## 2. 你必须掌握的“最容易卡住”的点：不变性 & 通配符

### 2.1 不变性（Invariance）：`List<Integer>` 不是 `List<Number>`

很多人直觉上觉得 Integer 是 Number，那 `List<Integer>` 应该也是 `List<Number>` —— **Java 不是这样**。

原因：如果允许赋值，会破坏类型安全：

```java
// 这是不允许的：List<Number> nums = new ArrayList<Integer>();
// 否则下面会发生：
/*
List<Number> nums = (List<Number>) (Object) new ArrayList<Integer>();
nums.add(3.14); // 往“本质是 List<Integer>”里塞 double，炸了
*/
```

### 2.2 通配符（Wildcard）三兄弟：`?` / `? extends` / `? super`

你可以这样记（面试官也爱听）：

- `? extends T`：**上界通配符**，表示“某个 T 的子类”
  - **适合读（producer）**，不适合写（consumer）
- `? super T`：**下界通配符**，表示“某个 T 的父类”
  - **适合写（consumer）**，读出来只能当 Object
- 口诀：**PECS = Producer Extends, Consumer Super**

------

## 3. 最重要的实战：PECS 经典 demo（背下来能回答一堆题）

```java
import java.util.*;

public class Demo04_PECS {
    static void copy(List<? super Number> dst, List<? extends Number> src) {
        for (Number n : src) dst.add(n);
    }

    public static void main(String[] args) {
        List<Integer> src = List.of(1, 2, 3);
        List<Number> dst = new ArrayList<>();

        copy(dst, src);
        System.out.println(dst); // [1, 2, 3]
    }
}
```

解释：

- `src` 是“生产者”（你只从它读 Number）→ `? extends Number`
- `dst` 是“消费者”（你往里写 Number）→ `? super Number`

**面试常问**：为什么 `extends` 里不能 add？

```java
List<? extends Number> list = new ArrayList<Integer>();
// list.add(1); // 编译不让：因为它可能是 List<Double>，你加 Integer 会破坏类型安全
Number n = list.get(0); // 读是安全的
```

------

## 4. 常见约束：上界、多个上界、自限定（面试高频 + 读代码必备）

### 4.1 上界：`<T extends Number>`

```java
public class Demo05_Bounds {
    static <T extends Number> double sum(T a, T b) {
        return a.doubleValue() + b.doubleValue();
    }

    public static void main(String[] args) {
        System.out.println(sum(1, 2));       // Integer
        System.out.println(sum(1.5, 2.5));   // Double
        // sum("1","2") // 编译报错
    }
}
```

### 4.2 多个上界：`<T extends A & B & C>`

注意：**类只能放第一个**，后面都是接口

```java
import java.util.*;

public class Demo06_MultiBounds {
    static <T extends Number & Comparable<T>> T max(T a, T b) {
        return a.compareTo(b) >= 0 ? a : b;
    }

    public static void main(String[] args) {
        System.out.println(max(10, 20));
    }
}
```

### 4.3 自限定泛型（F-bounded）：读框架源码经常见

比如很多 fluent API、builder、枚举式约束：

```java
public class Demo07_SelfBounded {
    interface Self<T extends Self<T>> {
        T self();
    }

    static class User implements Self<User> {
        @Override public User self() { return this; }
        public User name(String n) { System.out.println("name=" + n); return this; }
    }

    public static void main(String[] args) {
        new User().self().name("Tom");
    }
}
```

------

## 5. 日常业务开发里的高频泛型场景（你能立刻用上）

### 场景 A：统一返回体 `Result<T>`

```java
public class Demo08_Result {
    static class Result<T> {
        final boolean success;
        final T data;
        final String error;

        private Result(boolean success, T data, String error) {
            this.success = success; this.data = data; this.error = error;
        }
        static <T> Result<T> ok(T data) { return new Result<>(true, data, null); }
        static <T> Result<T> fail(String error) { return new Result<>(false, null, error); }
    }

    public static void main(String[] args) {
        Result<String> r1 = Result.ok("hi");
        Result<Integer> r2 = Result.ok(100);
        System.out.println(r1.data);
        System.out.println(r2.data + 1);
    }
}
```

**优点**：接口统一、类型安全、可读性强
**缺点**：容易被滥用（层层包裹导致代码啰嗦），注意别把异常处理全吞了

### 场景 B：分页 `Page<T>`

```java
import java.util.*;

public class Demo09_Page {
    static class Page<T> {
        final List<T> items;
        final long total;
        Page(List<T> items, long total) { this.items = items; this.total = total; }
    }

    public static void main(String[] args) {
        Page<String> p = new Page<>(List.of("a", "b"), 2);
        System.out.println(p.items);
    }
}
```

### 场景 C：通用 Repository / DAO（非常“业务”）

```java
import java.util.*;

public class Demo10_Repository {
    static class BaseEntity {
        Long id;
        BaseEntity(Long id) { this.id = id; }
    }
    static class User extends BaseEntity {
        String name;
        User(Long id, String name) { super(id); this.name = name; }
        @Override public String toString(){ return "User(" + id + "," + name + ")"; }
    }

    interface Repository<T extends BaseEntity, ID> {
        Optional<T> findById(ID id);
        void save(T entity);
    }

    static class UserRepo implements Repository<User, Long> {
        private final Map<Long, User> db = new HashMap<>();
        public Optional<User> findById(Long id) { return Optional.ofNullable(db.get(id)); }
        public void save(User u) { db.put(u.id, u); }
    }

    public static void main(String[] args) {
        UserRepo repo = new UserRepo();
        repo.save(new User(1L, "Alice"));
        System.out.println(repo.findById(1L).orElseThrow());
    }
}
```

**取舍**：

- 泛型 Repository 让“通用 CRUD”抽象更清晰
- 但别为了抽象而抽象：复杂查询、联表、聚合，抽象过度会导致表达力下降（业务里经常发生）

------

## 6. 你必须知道的限制（面试官最爱问“为什么不行”）

### 6.1 为什么不能 `new T()`？

因为运行时擦除后，`T` 的具体类型没了，JVM 不知道要 new 什么。

**解决方式**：传 `Class<T>` 进来（业务常用）

```java
public class Demo11_ClassToken {
    static class Factory {
        static <T> T create(Class<T> clazz) {
            try {
                return clazz.getDeclaredConstructor().newInstance();
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
    }

    static class A { public A() {} }

    public static void main(String[] args) {
        A a = Factory.create(A.class);
        System.out.println(a);
    }
}
```

### 6.2 为什么不能 `new T[]`？

同理：数组需要运行时知道元素类型（数组是“运行时带类型信息”的），泛型擦除让它不成立。

常见替代：

- 用 `List<T>`
- 或者 `Array.newInstance(clazz, n)`（需要 `Class<T>`）

### 6.3 为什么不能 `instanceof List<String>`？

运行时只有 `List`，没有 `List<String>` 的信息可判断。

------

## 7. API 设计里最重要的“写法选择”：用通配符还是用类型参数？

### 7.1 什么时候用 `<?>`

- 你只关心“它是个 List”，元素类型无所谓（比如打印大小）

```java
static void printSize(java.util.List<?> list) {
    System.out.println(list.size());
}
```

### 7.2 什么时候用 `<T>`

- 当**同一个类型**在方法参数/返回值之间存在“关联关系”

```java
import java.util.*;

public class Demo12_TypeParamVsWildcard {
    // 返回值类型和入参元素类型关联 -> 用 <T>
    static <T> T last(List<T> list) {
        return list.get(list.size() - 1);
    }

    // 不关心元素类型 -> 用 ?
    static void printAny(List<?> list) {
        for (Object o : list) System.out.println(o);
    }

    public static void main(String[] args) {
        System.out.println(last(List.of("a","b")));
        printAny(List.of(1,2,3));
    }
}
```

------

## 8. 面试速答题库（你背熟能打 80% 泛型面试）

1. **Java 泛型是协变还是不变？**

- `List<T>` **不变**。`List<Integer>` 不是 `List<Number>`。

1. **? extends 和 ? super 的区别？**

- `extends` 适合读，`super` 适合写。口诀 **PECS**。

1. **为什么 List<? extends Number> 不能 add？**

- 因为它可能是 `List<Double>`，add Integer 会破坏类型安全。

1. **什么是类型擦除？带来什么限制？**

- 编译后泛型信息被擦除，运行时看不到 T；所以不能 `new T()`、`new T[]`、`instanceof List<String>`。

1. **什么是 Raw Type（原生类型）？为什么不要用？**

- `List list = new ArrayList();`
- 会丢失类型检查，容易在别处爆 `ClassCastException`。

1. **List<?> 能 add 吗？**

- 不能（除了 `add(null)`），因为不知道具体类型。

1. **什么时候在参数上用 ? super T？**

- 当你要往里面“放 T”（消费者），比如 `Comparator<? super T>` 这种常见写法。

------

## 9. 练习建议（最快形成肌肉记忆）

你在刷题/业务里遇到泛型，先问自己三件事：

1. 这是“**读**”多还是“**写**”多？→ 决定 extends/super
2. 我是否需要“**类型关联**”（入参/返回值同一 T）？→ 决定 `<T>` 还是 `<?>`
3. 我是不是在试图做“运行时类型判断/创建”？→ 想到擦除，考虑 `Class<T>` token

- 你主要做 **Spring/后端业务** 还是偏 **算法/刷题**？
- 你常看到的代码是 `<? extends ...>` 多，还是 `Repository<T, ID>` 多？

不管你回不回，我也能继续：下一步我可以给你一套 **10 道从易到难的泛型小练习**（每题都对应一个高频坑点：capture、PECS、bounds、raw type、@SafeVarargs 等），你写完我逐题帮你改到“面试能说清楚为止”。